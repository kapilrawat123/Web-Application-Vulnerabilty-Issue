{
	"nodes":[
		{"id":"8a4251e532bf1191","type":"text","text":"> ### **Not Verifying the Signature**","x":-120,"y":-36,"width":440,"height":116},
		{"id":"dca678113f6d40da","type":"text","text":"> **The first issue with signature validation is when there is no signature validation. If the server does not verify the signature of the JWT, then it is possible to modify the claims in the JWT to whatever you prefer them to be. While it is uncommon to find APIs where no signature validation is performed, signature validation may have been omitted from a single endpoint within the API. Depending on the sensitivity of the endpoint, this can have a significant business impact.**","x":481,"y":-91,"width":929,"height":231},
		{"id":"29fcfbc2ec856196","type":"text","text":"> ### **Downgrading to None**","x":-120,"y":265,"width":440,"height":130},
		{"id":"f75a4aa029a6c738","type":"text","text":"> ### **Sensitive Information Disclosure**","x":-120,"y":-400,"width":380,"height":140},
		{"id":"091ebf4320437f33","type":"text","text":"> ### **Weak Symmetric Secrets**","x":-120,"y":690,"width":440,"height":140},
		{"id":"36505cae3bd1a92b","type":"text","text":"> **Another common issue is a signature algorithm downgrade. JWTs support the** \" ==`None`== \" **signing algorithm, which effectively means that no signature is used with the JWT. While this may sound silly, the idea behind this in the standard was for server-to-server communication, where the signature of the JWT was verified in an upstream process. Therefore, the second server would not be required to verify the signature. However, suppose the developers do not lock in the signature algorithm or, at the very least, deny the** \" ==`None`== \"  **algorithm. In that case, you can simply change the algorithm specified in your JWT as** \" ==`None`== \", **which would then cause the library used for signature verification to always return true, thus allowing you again to forge any claims within your token.**","x":481,"y":180,"width":964,"height":300},
		{"id":"24a61b46014fc0f2","type":"text","text":"> If a symmetric signing algorithm is used, the security of the JWT relies on the strength and entropy of the secret used. If a weak secret is used, it may be possible to perform offline cracking to recover the secret. Once the secret value is known, you can again alter the claims in your JWT and recalculate a valid signature using the secret.\n> \n> For this example, a weak secret was used to generate the JWT. Once you receive a JWT, you have several options to crack the secret. For our example, we will talk about using [Hashcat](https://hashcat.net/hashcat/) to crack the JWT's secret. You could also use other solutions such as [John](https://www.openwall.com/john/) as well. You can use the following steps to crack the secret:\n> \n> 1. Save the JWT to a text file called jwt.txt.\n> 2. Download a common JWT secret list. For this room, you can use `wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list` to download such a list.\n> 3. Use **Hashcat** to crack the secret using `hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list`\n> ","x":481,"y":520,"width":884,"height":480},
		{"id":"efc75d36e2f3e1af","type":"text","text":"### **Signature Algorithm Confusion**","x":-120,"y":1161,"width":440,"height":120},
		{"id":"abb5cc1550732397","type":"text","text":"> The last common issue with signature validation is when an algorithm confusion attack can be performed. This is similar to the `None` downgrade attack, however, it specifically happens with confusion between symmetric and asymmetric signing algorithms. If an asymmetric signing algorithm, for example, RS256 is used, it may be possible to downgrade the algorithm to HS256. In these cases, some libraries would default back to using the public key as the secret for the symmetric signing algorithm. Since the public key can be known, you can forge a valid signature by using the HS256 algorithm in combination with the public key.","x":481,"y":1080,"width":884,"height":282},
		{"id":"e7acc47da9e4b092","type":"text","text":"> **A common cookie-based session management approach is using the server-side session to store several parameters. In PHP, for example, you can use $SESSION['var']=data to store a value associated with the user's session. These values are not exposed client-side and can therefore only be recovered server-side. However, with tokens, the claims are exposed as the entire JWT is sent client-side. If the same development practice is followed, sensitive information can be disclosed. Some examples are seen on real applications:**\n> \n> - Credential disclosure with the password hash, or even worse, the clear-text password being sent as a claim.\n> - Exposure of internal network information such as the private IP or hostname of the authentication server.","x":481,"y":-520,"width":900,"height":380},
		{"id":"428c83684d43adb1","type":"text","text":"> # **JSON WEB TOKENS  (ISSUE)**","x":-1200,"y":670,"width":480,"height":181},
		{"id":"5f1c5c2e0164b99c","type":"text","text":"> [!NOTE] \n> Before verifying the signature of the token, the lifetime of the token should be calculated to ensure that the token has not expired. This is usually performed by reading the `exp` (expiration time) claim from the token and calculating if the token is still valid.\n\nA common issue is if the `exp` value is set too large (or not set at all), the token would be valid for too long or might even never expire.\nAnd you can regain to any time. \n\nCheck this problem also and this vulnerability in web application.","x":481,"y":1440,"width":634,"height":420},
		{"id":"30053f137b1b8520","type":"text","text":"### **Token Lifetime**","x":-120,"y":1590,"width":340,"height":120},
		{"id":"d59dae152d163913","type":"text","text":"This is similar to Downgrading to None vulnerability.  Except this time, the None algorithm is not allowed. However, once you authenticate you will receive the public key. As the public key isn't regarded as sensitive, it is common to find the public key. Sometimes, the public key is even embedded as a claim in the JWT. you must downgrade the algorithm to HS256 and then use the public key as the secret to sign the JWT. \n\n> - **You can use the script provided below to assist you in forging this JWT:**\n> \n> ```python\n> import jwt\n> \n> public_key = \"ADD_KEY_HERE\"\n> \n> payload = {\n>     'username' : 'user',\n>     'admin' : 0\n> }\n> \n> access_token = jwt.encode(payload, public_key, algorithm=\"HS256\")\n> print (access_token)\n> ```\n\n> [!NOTE]\n> \n> We recommend that you use  Python virtual environment for using this code.\n> \n> > ```\n> > virtualenv -p python3  {virtualenv-name}\n> > ```\n> \n> \n> - After that install  `Pyjwt`\n> > `pip3 install pyjwt`\n> \n> You will also need to tamper with the Pyjwt library's algorithm.py file on line `258` to remove the `is_ssh_key` condition as a patch for this vulnerability was released. Keep in mind that this placement can vary per VM and installation. An easier method if you are not comfortable with library code edits is to make use of [jwt.io](https://jwt.io). Once you verify it works, you can alter the claims to make get yourself what you want.","x":1480,"y":721,"width":820,"height":1000},
		{"id":"8d28756657da021d","type":"text","text":"> Cross-Service Relay Attacks exploit JWTs' lack of audience (aud) claim verification. In this attack:\n> \n> 1. A legitimate JWT issued for one service (e.g., `Service A`) is relayed to another service (`Service B`).\n> 2. If `Service B` does not verify the `aud` claim or check the intended audience, it might accept the token and provide unauthorized access to its resources.\n\n---\n\n> [!NOTE]\n> 1. **The attacker obtains a JWT from `Service A` after legitimate authentication.**\n> 2. **The attacker uses the JWT on `Service B` without re-authentication.**\n> 3. **If `Service B` fails to validate the `aud` claim, it grants access based on the JWT.**\n\n","x":481,"y":1900,"width":739,"height":560},
		{"id":"13742017f824ebe5","type":"text","text":"### **Cross-Service** Relay Attacks","x":-120,"y":2118,"width":408,"height":125}
	],
	"edges":[
		{"id":"667f9902e9e0a9d8","fromNode":"428c83684d43adb1","fromSide":"right","toNode":"f75a4aa029a6c738","toSide":"left"},
		{"id":"6707a921c781d495","fromNode":"428c83684d43adb1","fromSide":"right","toNode":"8a4251e532bf1191","toSide":"left"},
		{"id":"4840c691a31c6a57","fromNode":"8a4251e532bf1191","fromSide":"right","toNode":"dca678113f6d40da","toSide":"left"},
		{"id":"c23b6b2b5ed191b5","fromNode":"f75a4aa029a6c738","fromSide":"right","toNode":"e7acc47da9e4b092","toSide":"left"},
		{"id":"32e4af14cdc70bcb","fromNode":"428c83684d43adb1","fromSide":"right","toNode":"29fcfbc2ec856196","toSide":"left"},
		{"id":"2d9350aaf5626393","fromNode":"29fcfbc2ec856196","fromSide":"right","toNode":"36505cae3bd1a92b","toSide":"left"},
		{"id":"c26cd6c31a41d6f6","fromNode":"428c83684d43adb1","fromSide":"right","toNode":"091ebf4320437f33","toSide":"left"},
		{"id":"0da409f7ec50eaae","fromNode":"091ebf4320437f33","fromSide":"right","toNode":"24a61b46014fc0f2","toSide":"left"},
		{"id":"1d8111e686d1b5be","fromNode":"efc75d36e2f3e1af","fromSide":"right","toNode":"abb5cc1550732397","toSide":"left"},
		{"id":"57f03e5c7ab8901e","fromNode":"abb5cc1550732397","fromSide":"right","toNode":"d59dae152d163913","toSide":"left"},
		{"id":"140b4af44594dabe","fromNode":"428c83684d43adb1","fromSide":"right","toNode":"efc75d36e2f3e1af","toSide":"left"},
		{"id":"76629a7445546285","fromNode":"428c83684d43adb1","fromSide":"right","toNode":"30053f137b1b8520","toSide":"left"},
		{"id":"910728647a2fefb5","fromNode":"30053f137b1b8520","fromSide":"right","toNode":"5f1c5c2e0164b99c","toSide":"left"},
		{"id":"f6a42578ac01de79","fromNode":"428c83684d43adb1","fromSide":"right","toNode":"13742017f824ebe5","toSide":"left"},
		{"id":"7c5edfa8908126c3","fromNode":"13742017f824ebe5","fromSide":"right","toNode":"8d28756657da021d","toSide":"left"}
	]
}